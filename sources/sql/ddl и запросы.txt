CREATE TABLE positions (
    position_id INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    position_name VARCHAR(255) NOT NULL,
    salary_type_name VARCHAR(255) NOT NULL
);
CREATE TABLE managers (
    personal_manager_id INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    position_id INT,
    FOREIGN KEY (position_id) REFERENCES positions(position_id)
);

CREATE TABLE Services_types (
    service_id INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    service_name VARCHAR(255),
    amount int
);

CREATE TABLE Clients (
    user_id INT NOT NULL,
    client_name VARCHAR(256) NOT NULL,
    email VARCHAR(255),
    phone VARCHAR(20),
    personal_manager_id INT,
    client_segment VARCHAR(50) NOT NULL,
    client_region VARCHAR(50) NOT NULL,
    bank_account int,
    PRIMARY KEY (user_id),
    FOREIGN KEY (personal_manager_id) REFERENCES Managers(manager_id)
);

CREATE TABLE Deals (
    deal_id INT NOT NULL AUTO_INCREMENT,
    deal_start_date DATE,
    deal_end_date DATE,
    client_name VARCHAR(255),
    client_id INT,
    deal_amount INT,
    is_deal_ended BOOLEAN,
    current_deal_type VARCHAR(255),
    PRIMARY KEY (deal_id),
    FOREIGN KEY (client_id) REFERENCES Clients(client_id)
);

CREATE TABLE L_service_deal (
    service_in_deal_id INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    deal_type_id INT,
    deal_id INT,
    FOREIGN KEY (deal_type_id) REFERENCES Services_types(service_id),
    FOREIGN KEY (deal_id) REFERENCES Deals(deal_id)
);


CREATE TABLE Activities (
    Activity_id INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    deal_id INT,
    activity_type VARCHAR(255),
    duration INT,
    activity_start_date DATE,
    activity_end_date DATE,
    personal_manager_id INT,
    is_activity_reached_user BOOLEAN,
    FOREIGN KEY (deal_id) REFERENCES deals(deal_id),
    FOREIGN KEY (personal_manager_id) REFERENCES managers(manager_id)
);



CREATE TABLE transactions (
    transaction_id INT AUTO_INCREMENT PRIMARY KEY,
    bank_account VARCHAR(255),
    amount DECIMAL(10, 2), 
    event_time DATETIME,
    service_in_deal_id INT,
    FOREIGN KEY (service_in_deal_id) REFERENCES L_service_deal(service_id)
);
Задачка 1
--посчитать число клиентов в разрезе по сегменту клиентов, сделки с которыми были открыты в феврале 23 года, имеющие общую сумму по всем открытым сделкам больше 2000 рублей,
With need_users as (
    Select 
	client_id
    From deals 
    Where deal_start_date between '2023-02-01' and '2023-02-28'
    And not is_deal_ended
    Group by client_id 
    Having sum(deal_amount) > 2000
)
Select
    Client_segment,
    count(nu.client_id) as cnt_users
From Clients c
Left Join need_users nu on c.client_id = nu.client_id

Задачка 2
--Определить ведущий тип услуги для каждого id клиента на основании его трат в сделках
With pre_ag as (
Select 
    st.service_name,
    d.client_id,
    row_number() over(partition by d.client_id order by sum(deal_amount) desc as rnk
From deals d  
Left Join L_service_deal using(deal_id)
Left join Services_types st using(service_type_id)
Group by 1,2
	)
Select 
   client_id,
   service_name
From pre_ag 
Where ink = 1


Теория
1) Нормальные формы БД - всего 6 типов, один подтип для 3 НФ
    1) I НФ - нет дубликатов строк, все данные в ячейках атомарны, данные одного типа
    2) II НФ - таблица в I нф + все неключевые атрибуты зависят целиком от всего ключа, а не от отдельных его составляющих
    3) III НФ - таблица во II нф + нет транзитивных зависимостей от неключевых атрибутов 
    4) Бойса — Кодда детерминанты всех её функциональных зависимостей являются потенциальными ключами
    5) IV НФ - в форме Бойса - Кодда и нетривиальные зависимости являются функциональными зависимости
    6) V НФ - каждая нетривиальная зависимость соединения в нём определяется потенциальным ключом (ключами) этого отношения
    7) VI НФ - для хронологических бд 5НФ + дальнейшая декомпозиция без потерь невозможна
2) Снежинка и звезда - архитектуры хранилищ данных.
Звезда - два типа таблиц в центре - таблица фактов состоит из различных измерений и их количественных характеристик, 
С ней связаны - таблицы измерений, описывающая измерения и их атрибуты
Снежинка - ее модификация, когда таблицы измерений декомпозируются дальше на нормальные формы