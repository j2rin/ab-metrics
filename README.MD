# Инструкция

## Порядок заведения метрик
### 1. Определиться с источником

- Конфиг источников: sources.yaml
- Лучше переиспользовать один из существующих
- Если нужен новый источник, то необходимо описать его SQL и метаданные
  в конфиге по аналогии

### 2. Объявить метрику в конфиге

- Конфиги метрик в папке `metrics`
- Синтаксис объявления метрик описан ниже

Связь метрик с источником прописывается в sources.yaml двумя способами:
1. С помощью списка metric_configs, в котором указываются имена файлов с конфигами
2. С помощью списка metrics с явным перечислением метрик

Одна и та же метрика может быть привязана к разным источникам при условии, что
эти источники находятся в раздых БД. Возможность привязать метрику к разным
источникам сделана для заведения источников в clickhouse,
и использовать метрики, изначально созданные для Вертики.

### 3. Валидировать и создать PR

#### Локальная валидация
- Запускается так: `python validate.py`.
- Для работоспособности скрипта его нужно запускать в третьем питоне,
  предварительно сделав `pip install -r requirements.txt`
- Потребуются секреты вертики. Их необходимо прописать
  в файлике `.env` в таком формате

```
VERTICA_USER="<login>"
VERTICA_PASSWORD="<password>"
```

- Если есть ошибки, скрипт выведет их консоль. Их следует исправить
  и запустить скрипт заново

#### PR и валидация в Stash

- Запушить ветку / создать PR. Файл `.env` пушить нельзя!
- Билд валидации запустится автоматически
- Результат работы билда отобразится в комментариях PR
- В случае успеха попросить мерджа в [~ab-central-help](https://mt.avito.ru/avito/channels/ab-central-help)

------

## Порядок заведения дименшенов

Новые дименшены заводятся, чтобы иметь возможность добавлять их в слайсы (брейкдауны) АБ,
или в столбцы M42 (что делается реже и, ввиду большого выходного объема, — под присмотром DWH).

1. Добавить новый дименшен в dimensions/dimensions.yaml по аналогии с уже заведенными дименшенами. Синтаксис описан ниже.
2. Добавить sql для извлечения значений дименшенов в dimensions/sql в файл <название дименшена>.sql

Очень желательно, чтобы у дименшена был айдишник, а не только varchar-представление.

------
## Синтаксис

### Дименшены
Конфиг `dimensions.yaml`. Ключом является общепринятый идентификатор дименшена.
- `level` — откуда берется дименшен. _event_ — из источника, _participant_ приджойнивается из _participant_dimension_.
  Есть еще _buyer_segment_ и _ab_participant_. Эта область не автоматизирована, джоины прописаны руками в коде сборки АБ и M42.
  Самый простой и распространенный вариант — _event_.
- `parent` — ключ дименшена, который считается родительским. Например, _vertical_ для _logical_category_.
- `is_bool` — флаг, что дименшен имеет тип boolean 
- `has_id` — в источниках дименшен представлен в виде id, столбец имеет имя <dimension_name>_id
- `description` — краткое описание дименшена
- `slug` — понятный человеку идентификатор дименшена

SQL запросы для извлечения значений дименшена могут содержать следующие колонки:
- `value` - значение дименшена
- `value_id` - идентификатор значения дименшена
- `value_ext_id` - внешний идентификатор значения дименшена
- `parent_dimension` - название родительского дименшена
- `parent_value` - значение родительского дименшена
- `parent_value_id` - идентификатор значения родительского дименшена
- `parent_value_ext_id` - внешний идентификатор значения родительского дименшена
- `is_active` - признак актуальности значения 

Обратите внимание, что колонка `value` является обязательной.


### Источники
SQL источников описывается в файлах в папке sources/sql. 
SQL должен содержать параметры `:first_date` и `:last_date`

Конфиг `sources.yaml`
- `sql` — имя файла с SQL-кодом источника. Обязательное поле
- `column_map` — маппинг наименований из конфигов метрик на колонки в таблице  
- `dimensions` — список дименшенов (ключи из dimensions.yaml), которые есть в источнике
- `participant` — маппинг, какой столбец отвечает за visitor, а какое за user (обычно cookie_id и user_id). Обязательное поле
- `primary_subject` — какой participant считать за основной. Обычно это visitor, если он есть
- `dtm` — колонка с датой/таймстампом. Обязательное поле
- `database` — vertica или clickhouse


### Метрики
Конфиги в папке `metrics`.

Метрики делятся на три типа. Каждый — в отдельном блоке конфига.
1. Простые каунтеры `metric.counter`. Аргументы:
    - `filter`: условие, фильтрующее нужные строки, перед тем как их сложить. Синтаксис описан в следующем разделе
    - `obs`: колонка (или список), значения которой нужно складывать. Если не указана, то подставляется 1
2. Уники `metric.uniq`. Аргументы:
    - `counter`: имя каунтера из первого блока.
    - `key`: колонка уникальные значения которой мы считаем. Можно считать уникальные значения по составному ключу,
      для этого в key указать его алиас (напр. `cookie_logcat`), а в column_map в конфиге источника прописать маппинг
      на список колонок (`cookie_logcat: [cookie_id, logical_category_id]`)
    - `threshold`: порог, по которому учитываем уника при условии sum(counter) > threshold. Если не указан, то 0.
3. Ratio: `metric.ratio`. Оба аргумента — ссылки на существующие метрики из пп. 1-2.
    - `num`: числитель
    - `den`: знаменатель

После успешного создания метрики и мерджа, на ее [странице в админке ab.k.avito.ru](https://ab.k.avito.ru/metrics?metric=buyers_canonical)
можно увидеть сгенерированный sql, и проверить логику расчета.

### Синтаксис каунтеров
Условие в фильтре имеет формат ключ-значение. Ключом является имя столбца в источнике. В поле `obs` указываются столбцы, которые нужно сложить. Например, метрику с конфигом
`phone_views: {filter: [eid: 303], obs: [events_count]}` в SQL можно вычислить как `select sum(events_count) as phone_views from source where eid = 303`.

К столбцам в фильтре можно применять операторы. Оператор применяется через точку.

|Оператор|Примеры|Аналог в SQL|
|:---|:----|:----|
|`=, !=, <=, >=, <, >` |`a.>=: 1`|`a >= 1`|
|`in, !in`|`a.in: [1, 2, 3]`|`a in (1, 2, 3)`|
|`bit, !bit`|`a.bit: 5, a.bit: [4, 5]`|`a & (1 << 5) > 0, (a & (1 << 4) > 0 or a & (1 << 5) > 0)`|
|`isnull`|`a.isnull: true, a.isnull: false`|`a is null, a is not null`|

Условия в фильтре объявляются через запятую, а потом преобразуются в SQL через `and`. Для более сложных выражений существует ключевое слово `$or`.

Пример конфига:
```yaml
filter: [x_eid: 300, $or: [platform_id.!=: 1, flags.!bit: 4]]
```
Аналог в SQL:
```sql
where x_eid = 300 and (platform_id != 1 or flags & (1 << 4) = 0)
```

Допускается использовать вложенные `$or`.


### Definitions
Для упрощения кода в конфиге можно часто используемые конструкции объявить заранее, а потом использовать ссылки на них. 
Для этого используется синтаксис [якорей YAML](https://support.atlassian.com/bitbucket-cloud/docs/yaml-anchors/).

Пример:
```yaml
definitions:
  - &eid_search   [300]
  - &eid_rec      [2437, 2012, 2309]
  - &x_is_search  {x_eid: *eid_search}  # ссылка на якорь eid_search, объявленный в первой строке
  - &x_is_rec     {$or: [[x_eid: *eid_rec], [x_engine: sg-rec]]}

metric.counter:
  rec_events: {filter: *x_is_rec}
```


### M42 Cartesian Groups
Конфиг задает комбинации разрезов для m42. Есть возможность тонко настроить для каких метрик какие разрезы и их 
комбинации будут считаться в витрине dma.m42 и соответственно будут доступны в дашборде [m42.k](https://m42.k.avito.ru/).

**group** — список разрезов, по которым будет произведена группировка без расчета промежуточного итога (Any). Сюда 
следует добавлять разрезы, по которым метрики всегда аддитивны. Значение Any для таких разрезов расчитывать избыточно, 
потому что простая сумма даст корректный результат, а тратить небесконечные ресурсы на расчет мы не любим.

**cube** — список разрезов, для которых будет посчитаны всевозможные комбинации промежуточных итогов 
(их количество равно `2^n`). Например, для cube `[A, B, C]` будут посчитаны всевозможные группировки (их `2^3 = 8`):
```
- (A, B, C) — группировка по всем встречающимся комбинациям значений
- (A, B)
- (A, C)
- (B, C)
- (A)
- (B)
- (C)
- () — все разрезы принимают значение Any
```
Обращаем внимание, что указание cube с большим количеством разрезов приведет к комбинаторному взрыву количества строк 
в результате, поэтому рекомендуется ограничиваться 3-5 разрезами на один список.

Можно не беспокоиться насчет указания одинаковых комбинаций cube для одной и той же метрики несколько раз, потому что 
движок расчетов сам сделает уникализацию и не допустит дублирования данных на выходе. Поэтому у вас есть возможность 
настраивать комбинации как по индивидуальным метрикам (`cubes_by_metrics`), так и в составе коллекций — по 
спискам (`cubes_by_metric_sets`), тегам (`cubes_by_tags`) или целым конфигам (`cubes_by_metric_configs`).
